C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE PMPDATAR
OBJECT MODULE PLACED IN PMPDataR.OBJ
COMPILER INVOKED BY: D:\keil4\C51\BIN\C51.EXE PMPDataR.c LARGE BROWSE INCDIR(.\SRC) DEBUG OBJECTEXTEND

line level    source

   1          
   2          #include "reg52.h" 
   3          #include "bmp.h"
   4          #include "oled.h"
   5          #include "steppermotorcontrol.h"
   6          #include "PlayMusic.h"
   7          #include "EEPROM.h"
   8          #include "sbit.h"
   9          #include "uart.h"
  10          #include "fpm10a.h"
  11          #include <string.h>
  12          #include<absacc.h>
  13          
  14          #define u16 unsigned int
  15          #define u8 unsigned char
  16          
  17          //可显示的元件
  18          
  19          bit set_password=0;
  20          bit use_password=0;
  21          bit set_music=0;
  22          bit use_rfid=0;//接受来自从机的bit
  23          bit password_visble=0;
  24          bit password_right=0;
  25          bit visble_justnow=0;
  26          bit visble_change_near=0;
  27          bit row_1=0;
  28          bit row_2=0;
  29          bit flag_open=0;
  30          bit clock_play_music = 0;
  31          
  32          u8 song1;
  33          u8 song2;
  34          u8 song3;
  35          u8 song4;
  36          u8 song5;
  37          
  38          u8 n;
  39          u8 password[32];
  40          u8* p=password;
  41          u8 input[32];
  42          u8 input_buf[32]="********************************";
  43          u8 i=0;
  44          u8 key_value;   //用来存放读取到的键值
  45          u8 column_temp;
  46          char i_temp=-1;//timevar是时间变量控制延时时间,
  47          u8 row=0;
  48          u16 a=0;
  49          u16 time_var=2;
  50          u8 song_set[5];
  51          u8* p_clock=song_set;
  52                         
  53          extern void delay_main(u16 t)
  54          {
  55   1              u16 i;
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 2   

  56   1              while(t--)
  57   1              {
  58   2                      /* 对于11.0592M时钟，约延时1ms */
  59   2                      for (i=0;i<125;i++)
  60   2                      {}
  61   2              }
  62   1      }
  63          
  64          void main_Buzz_Times(u8 k)
  65          { 
  66   1       u8 i,j;
  67   1      for(j=0;j<k;j++)
  68   1      {
  69   2        for(i=0;i<100;i++)
  70   2       { 
  71   3        BeepIO=~BeepIO;
  72   3        Delay_Us(100);
  73   3       }
  74   2       Delay_Ms_fpm(200);
  75   2      }
  76   1      BeepIO=1;  
  77   1      }
  78          
  79          void delay(u16 i)
  80          {
  81   1              while(i--);     
  82   1      }
  83           
  84          void warn(u8 k)
  85          {
  86   1              u8 i,j;
  87   1              for(j=0;j<k;j++)
  88   1              {
  89   2              for(i=0;i<100;i++)
  90   2              { 
  91   3              BeepIO=~BeepIO;
  92   3               Delay_Us(100);
  93   3              }
  94   2              }
  95   1              BeepIO=1;  
  96   1      } 
  97          
  98          void led_blink_times(u8 j)
  99          {
 100   1        u8 i=0;
 101   1        for(i=0;i<j;i++)
 102   1        {
 103   2              LED=0;
 104   2              delay(5000);
 105   2          LED=1;
 106   2              delay(3000);
 107   2        }
 108   1      }
 109          
 110          void EEPROM_init()
 111          {
 112   1         EEPROM_READ(0,p,32);
 113   1         EEPROM_READ(1,p_clock,5);
 114   1                  song1=song_set[0];
 115   1                      song2=song_set[1];
 116   1                      song3=song_set[2];
 117   1                      song4=song_set[3];
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 3   

 118   1                      song5=song_set[4];
 119   1              EEPROM_READ(2,errors,3);
 120   1      }
 121          
 122          void motor_on()
 123          { 
 124   1        if(flag_open==1)
 125   1       {
 126   2        a=0;
 127   2        while(1)
 128   2        {
 129   3              MotorAccOrDec(time_var,5);
 130   3              a++;
 131   3              if(a==765)
 132   3              {
 133   4                MotorStop();goto k;
 134   4              }
 135   3        }
 136   2      k://Play_Music4();
 137   2        delay_main(1000);
 138   2        a=0;
 139   2        while(1)
 140   2        {
 141   3              MotorAccOrDec(time_var,0);
 142   3              a++;
 143   3              if(a==765)
 144   3              {
 145   4                MotorStop();goto l;
 146   4              }
 147   3        }
 148   2      l:
 149   2        a=0;
 150   2        flag_open=0;
 151   2       }
 152   1      }
 153          void key_pros()
 154          {
 155   1        if(status==0&&is_lock==1&&use_password==0&&use_fingerprint==0&&use_rfid==0&&key_value>=1&&key_value<=3)
 156   1        {
 157   2         switch(key_value)
 158   2         {
 159   3          case 1:
 160   3              use_password=1;
 161   3              key_value=16;
 162   3              OLED_Clear();
 163   3              break;
 164   3              case 2:
 165   3              use_fingerprint=1;
 166   3              key_value=16;
 167   3              OLED_Clear();
 168   3              break;
 169   3              case 3:
 170   3              use_rfid=1;
 171   3              key_value=16;
 172   3              OLED_Clear();
 173   3              break;
 174   3              default:break;
 175   3         }
 176   2        }
 177   1        if(status==0&&is_lock==1&&use_password==1&&key_value>=0&&key_value<=15)
 178   1        {     
 179   2              switch(key_value)
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 4   

 180   2              {
 181   3                case 0:if(i==32){break;}else{input[i]='0'+0;i++;break;}
 182   3                case 1:if(i==32){break;}else{input[i]='0'+1;i++;break;}
 183   3                case 2:if(i==32){break;}else{input[i]='0'+2;i++;break;}
 184   3                case 3:if(i==32){break;}else{input[i]='0'+3;i++;break;}
 185   3                case 4:if(i==32){break;}else{input[i]='0'+4;i++;break;}
 186   3                case 5:if(i==32){break;}else{input[i]='0'+5;i++;break;}
 187   3                case 6:if(i==32){break;}else{input[i]='0'+6;i++;break;}
 188   3                case 7:if(i==32){break;}else{input[i]='0'+7;i++;break;}
 189   3                case 8:if(i==32){break;}else{input[i]='0'+8;i++;break;}
 190   3                case 9:if(i==32){break;}else{input[i]='0'+9;i++;break;}
 191   3                case 10:if(i==32){break;}else{input[i]='a';i++;break;}
 192   3                case 11:if(i==32){break;}else{input[i]='b';i++;break;}
 193   3                case 12:if(i>=0)
 194   3                {
 195   4                if(i==16)
 196   4                {
 197   5                 row-=1;
 198   5                 if(row==0)
 199   5                 {
 200   6                       row_1=0;
 201   6                 }
 202   5                }
 203   4                if(i==32)
 204   4                {
 205   5                 row-=1;
 206   5                }
 207   4                if(i==0)
 208   4                {
 209   5                break;
 210   5                }
 211   4                OLED_Clear_Line(5+row);input[i]='\0';i--;
 212   4                 break;
 213   4                }
 214   3                case 13:
 215   3                 if(password_visble==0&&visble_change_near==0)
 216   3                {
 217   4                password_visble=1;
 218   4                visble_change_near=1;
 219   4                }
 220   3                if(password_visble==1&&visble_change_near==0)
 221   3                {
 222   4                password_visble=0;
 223   4                }
 224   3                break;
 225   3                case 14:
 226   3                if(strlen(input)!=strlen(password))
 227   3                {
 228   4                 password_right=0;
 229   4                 goto m;
 230   4                }
 231   3                for(i=0;i<strlen(password);i++)//检验密码程序
 232   3                {
 233   4                      if(input[i]==password[i])
 234   4                      {
 235   5                       password_right=1;
 236   5                      }
 237   4                      else
 238   4                      {
 239   5                      password_right=0;
 240   5                      }
 241   4                      if(password_right==0)
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 5   

 242   4                      {
 243   5                      goto m;
 244   5                      }
 245   4                      if(i==strlen(password)&&password_right==1)
 246   4                      {
 247   5                      goto n;
 248   5                      }        
 249   4                }
 250   3                n:is_lock=0;
 251   3                errors[0]='0';
 252   3                errors[1]='0';
 253   3                EEPROM_WRITE(2,errors,3);
 254   3                open_just_now=1;
 255   3                for(n=0;n<i;n++)
 256   3                {
 257   4                  input[n]='\0';
 258   4                }
 259   3                i=0;
 260   3                row=0;
 261   3                break;
 262   3                m:OLED_Clear();
 263   3                OLED_ShowString(1,0,"Password Error!",18);
 264   3                main_Buzz_Times(5);
 265   3                errors[0]++;
 266   3                EEPROM_WRITE(2,errors,3);
 267   3                if(errors[0]=='3')
 268   3                {
 269   4                      errors[2]=1;
 270   4                      EEPROM_WRITE(2,errors,3);
 271   4                }
 272   3                OLED_ShowString(1,2,"Error times:",18);
 273   3                OLED_ShowChar(100,2,errors[0],18);
 274   3                led_blink_times(3);
 275   3                for(n=0;n<i;n++)
 276   3                {
 277   4                 input[n]='\0';
 278   4                }
 279   3                row_1=0;
 280   3                row_2=0;
 281   3                use_password=0;
 282   3                row=0;
 283   3                i=0;
 284   3                delay_main(500);
 285   3                OLED_Clear(); 
 286   3                break;
 287   3                case 15:
 288   3                for(n=0;n<i;n++)
 289   3                {
 290   4                 input[n]='\0';
 291   4                }
 292   3                row_1=0;
 293   3                row_2=0;
 294   3                use_password=0;
 295   3                row=0;
 296   3                i=0;
 297   3                OLED_Clear();
 298   3                break;
 299   3                default:break;
 300   3              }
 301   2        }
 302   1        if(status==1&&is_lock==0&&key_value>=0&&key_value<=15&&set_music==0)
 303   1        {     
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 6   

 304   2              switch(key_value)
 305   2              {
 306   3                case 0:if(i==32){break;}else{input[i]='0'+0;i++;break;}
 307   3                case 1:if(i==32){break;}else{input[i]='0'+1;i++;break;}
 308   3                case 2:if(i==32){break;}else{input[i]='0'+2;i++;break;}
 309   3                case 3:if(i==32){break;}else{input[i]='0'+3;i++;break;}
 310   3                case 4:if(i==32){break;}else{input[i]='0'+4;i++;break;}
 311   3                case 5:if(i==32){break;}else{input[i]='0'+5;i++;break;}
 312   3                case 6:if(i==32){break;}else{input[i]='0'+6;i++;break;}
 313   3                case 7:if(i==32){break;}else{input[i]='0'+7;i++;break;}
 314   3                case 8:if(i==32){break;}else{input[i]='0'+8;i++;break;}
 315   3                case 9:if(i==32){break;}else{input[i]='0'+9;i++;break;}
 316   3                case 10:if(i==32){break;}else{input[i]='a';i++;break;}
 317   3                case 11:if(i==32){break;}else{input[i]='b';i++;break;}
 318   3                case 12:if(i>=0)
 319   3                {
 320   4                if(i==16)
 321   4                {
 322   5                 row-=1;
 323   5                 if(row==0)
 324   5                 {
 325   6                       row_1=0;
 326   6                 }
 327   5                }
 328   4                if(i==32)
 329   4                {
 330   5                 row-=1;
 331   5                }
 332   4                if(i==0)
 333   4                {
 334   5                break;
 335   5                }
 336   4                OLED_Clear_Line(5+row);input[i]='\0';i--;
 337   4                 break;
 338   4                }
 339   3                case 13:
 340   3                 if(password_visble==0&&visble_change_near==0)
 341   3                {
 342   4                password_visble=1;
 343   4                visble_change_near=1;
 344   4                }
 345   3                if(password_visble==1&&visble_change_near==0)
 346   3                {
 347   4                password_visble=0;
 348   4                }
 349   3                break;
 350   3                case 14:
 351   3                for(n=0;n<strlen(password);n++)
 352   3                {
 353   4                      password[n]='\0';
 354   4                }
 355   3            for(n=0;n<strlen(input);n++)
 356   3                {
 357   4                      password[n]=input[n];
 358   4                }
 359   3                for(n=0;n<i;n++)
 360   3                {
 361   4                 input[n]='\0';
 362   4                }
 363   3                EEPROM_WRITE(0,password,32);
 364   3                status=0;
 365   3                set_password=0;
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 7   

 366   3                row_1=0;
 367   3                row_2=0;
 368   3                row=0;
 369   3                i=0;
 370   3                OLED_Clear();
 371   3                OLED_ShowString(24,3,"Reset",36);
 372   3                OLED_ShowString(24,4,"Successfully",36);
 373   3                led_blink_times(2);
 374   3                delay_main(500);
 375   3                OLED_Clear();
 376   3                break;
 377   3                case 15:
 378   3                for(n=0;n<i;n++)
 379   3                {
 380   4                 input[n]='\0';
 381   4                }
 382   3                row_1=0;
 383   3                row_2=0;
 384   3                status=0;
 385   3                set_password=0;
 386   3                row=0;
 387   3                i=0;
 388   3                OLED_Clear();
 389   3                break;
 390   3                default:break;
 391   3              }
 392   2        }
 393   1        if(status==0&&is_lock==0&&key_value>=1&&key_value<=4)
 394   1        {
 395   2              switch(key_value)
 396   2              {
 397   3               case 1:
 398   3               status=1;
 399   3               set_password=1;
 400   3               OLED_Clear();
 401   3               break;
 402   3               case 2:
 403   3               status=1;
 404   3               set_fingerprint=1;
 405   3               OLED_Clear();
 406   3               break;
 407   3               case 3:
 408   3               status=1;
 409   3               set_music=1;
 410   3               OLED_Clear();
 411   3               break;
 412   3               case 4:
 413   3               status=0;
 414   3               is_lock=1;
 415   3               OLED_Clear();
 416   3               OLED_ShowString(24,3,"Lock",36);
 417   3               OLED_ShowString(24,4,"Successfully!",36);
 418   3               Buzz_Times(2);
 419   3               led_blink_times(3);
 420   3               delay_main(500);
 421   3               OLED_Clear();
 422   3               break;
 423   3              }
 424   2        }
 425   1      }
 426          void keydown(void)
 427          {
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 8   

 428   1              char a=0;
 429   1              GPIO_KEY=0x0f;
 430   1              if(GPIO_KEY!=0x0f)//读取按键是否按下
 431   1              {
 432   2                      delay(1000);//延时10ms进行消抖
 433   2                      if(GPIO_KEY!=0x0f)//再次检测键盘是否按下
 434   2                      {       
 435   3                              //测试列
 436   3                              led_blink_times(1);
 437   3                              GPIO_KEY=0X0F;
 438   3                              switch(GPIO_KEY)
 439   3                              {
 440   4                                      case(0X07):     key_value=0;break;
 441   4                                      case(0X0b):     key_value=1;break;
 442   4                                      case(0X0d): key_value=2;break;
 443   4                                      case(0X0e):     key_value=3;break;
 444   4                              }
 445   3                              //测试行
 446   3                              GPIO_KEY=0XF0;
 447   3                              switch(GPIO_KEY)
 448   3                              {
 449   4                                      case(0Xe0):     key_value=key_value;break;
 450   4                                      case(0Xd0):     key_value=key_value+4;break;
 451   4                                      case(0Xb0): key_value=key_value+8;break;
 452   4                                      case(0X70):     key_value=key_value+12;break;
 453   4                              }
 454   3                      }
 455   2                      if(use_rfid==0)
 456   2                      {
 457   3                              if(set_fingerprint==0)          
 458   3                         {    
 459   4                              key_pros();
 460   4                         }
 461   3                      }
 462   2              }
 463   1              while((a<75)&&(GPIO_KEY!=0XF0))  //检测按键松手检测
 464   1              {
 465   2                      delay(100);
 466   2                      a++;
 467   2              }
 468   1      }
 469          
 470          
 471          void display_pros()
 472          {                       
 473   1         if(errors[2]==1)
 474   1         {
 475   2           EA = 0;
 476   2               OLED_ShowString(0,0,"Entry Denial!",30);
 477   2               OLED_ShowString(0,2,"Please try after 1 minute.",30);
 478   2               warn(20);
 479   2               delay_main(1000*3);
 480   2               OLED_Clear();
 481   2               if(errors[0]=='3')
 482   2               {
 483   3                       errors[0]='0';
 484   3                       EEPROM_WRITE(2,errors,3);
 485   3               }
 486   2               if(errors[1]=='3')
 487   2               {
 488   3                   errors[1]='0';
 489   3                       EEPROM_WRITE(2,errors,3);
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 9   

 490   3               }
 491   2               EA=1;
 492   2               errors[2]=0;
 493   2         }
 494   1         if(status==0&&is_lock==1&&use_password==0&&use_fingerprint==0&&use_rfid==0&&errors[2]==0)
 495   1         {
 496   2                      OLED_ShowString(7,0,"MultiFunc Lock",16);
 497   2                      OLED_ShowString(0,2,"select open mode",14);
 498   2                      OLED_ShowString(12,4,"1.password",10);
 499   2                      OLED_ShowString(12,5,"2.fingerprint",10);  
 500   2                      OLED_ShowString(12,6,"3.rfid card",10);
 501   2         }
 502   1         if(status==0&&is_lock==1&&use_fingerprint==1&&ini_over==0&&errors[2]==0)
 503   1         {
 504   2            ES=0;
 505   2                delay(100*125);
 506   2            Device_Check();
 507   2         }
 508   1         if(status==0&&is_lock==1&&use_fingerprint==1&&ini_over==1&&errors[2]==0)
 509   1         { 
 510   2            ini_over=0;
 511   2                FPM10A_Find_Fingerprint();
 512   2                if(use_fingerprint==0)
 513   2                {
 514   3                      OLED_Clear();
 515   3                }
 516   2         }
 517   1         if(password_visble==0&&visble_justnow==1&&errors[2]==0)
 518   1         {
 519   2            OLED_Clear();
 520   2                visble_justnow=0;
 521   2         }
 522   1          if(status==0&&is_lock==1&&use_password==1&&password_visble==0&&errors[2]==0)
 523   1         { 
 524   2          
 525   2               OLED_ShowString(0,2,"Please enter",30);
 526   2               OLED_ShowString(50,3,"password:",30);
 527   2               if(row==0)
 528   2              {
 529   3               for(n=0;n<i;n++)
 530   3               {
 531   4           OLED_ShowChar(8*n,5,input_buf[n],30);
 532   4               }
 533   3              }
 534   2              if(row_1==1)
 535   2              {
 536   3                for(n=0;n<16;n++)
 537   3               {
 538   4           OLED_ShowChar(8*n,5,input_buf[n],30);
 539   4               }
 540   3              }
 541   2               if(i==16&&row==0)
 542   2               {
 543   3                row++;row_1=1;
 544   3               }
 545   2               if(row==1)
 546   2               {
 547   3                 for(n=0;n<i-16;n++)
 548   3                 {
 549   4                 OLED_ShowChar(8*n,6,input_buf[n+16],30);
 550   4                 }
 551   3               }
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 10  

 552   2               if(row_2==1)
 553   2               {
 554   3                 for(n=0;n<16;n++)
 555   3                 {
 556   4                 OLED_ShowChar(8*n,6,input_buf[n+16],30);
 557   4                 }
 558   3               }
 559   2               if(i==32&&row==1)
 560   2               {
 561   3               row=2;row_2=1;
 562   3               }
 563   2         }
 564   1              if(status==0&&is_lock==1&&use_password==1&&password_visble==1&&errors[2]==0)
 565   1               {
 566   2                 if(visble_justnow==0)
 567   2                 {
 568   3                 OLED_Clear();
 569   3                 }
 570   2                 OLED_ShowString(0,2,"Please enter",30);
 571   2                 OLED_ShowString(50,3,"password:",30);
 572   2                 if(row==0)
 573   2                {
 574   3               for(n=0;n<i;n++)
 575   3               {
 576   4           OLED_ShowChar(8*n,5,input[n],30);
 577   4               }
 578   3              }
 579   2              if(row_1==1)
 580   2              {
 581   3                for(n=0;n<16;n++)
 582   3               {
 583   4           OLED_ShowChar(8*n,5,input[n],30);
 584   4               }
 585   3              }
 586   2               if(i==16&&row==0)
 587   2               {
 588   3                row++;row_1=1;
 589   3               }
 590   2               if(row==1)
 591   2               {
 592   3                 for(n=0;n<i-16;n++)
 593   3                 {
 594   4                 OLED_ShowChar(8*n,6,input[n+16],30);
 595   4                 }
 596   3               }
 597   2               if(row_2==1)
 598   2               {
 599   3                 for(n=0;n<16;n++)
 600   3                 {
 601   4                 OLED_ShowChar(8*n,6,input[n+16],30);
 602   4                 }
 603   3               }
 604   2               if(i==32&&row==1)
 605   2               {
 606   3               row=2;row_2=1;
 607   3               }
 608   2                 visble_justnow=1;
 609   2                 if(visble_change_near==1)
 610   2                 {
 611   3                      visble_change_near=0;
 612   3                 }
 613   2                }
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 11  

 614   1          if(status==0&&is_lock==1&&use_rfid==1&&errors[2]==0)
 615   1         {
 616   2                OLED_ShowString(0,1,"Waiting for card",30);
 617   2            send_byte(0x01);
 618   2                delay_ms(100);
 619   2                OLED_ShowString(0,4,"Press ini-button",30);
 620   2                OLED_ShowString(26,5,"to quit.",30);
 621   2                while(RI==0);
 622   2                use_rfid=0;
 623   2                OLED_Clear();
 624   2                ES=1;
 625   2         }
 626   1          if(status==0&&is_lock==0&&open_just_now==1&&errors[2]==0)
 627   1         {
 628   2            OLED_Clear();
 629   2                OLED_ShowString(58,4,"WELCOME!",36);
 630   2            led_blink_times(3);
 631   2                flag_open=1;
 632   2                motor_on();
 633   2                open_just_now=0;
 634   2                use_password=0;
 635   2                OLED_Clear();
 636   2         }
 637   1         if(status==0&&is_lock==0&&errors[2]==0)
 638   1         {
 639   2                OLED_DrawBMP(2,0,34,4,atom);
 640   2                OLED_ShowString(50,1,"MultiFunc",32);
 641   2                OLED_ShowString(70,2,"Lock",32);
 642   2                OLED_ShowString(0,4,"1.reset password",30);
 643   2                OLED_ShowString(0,5,"2.finger set",30);
 644   2                OLED_ShowString(0,6,"3.clockmusic set",30);
 645   2                OLED_ShowString(0,7,"4.lock",30);
 646   2         }
 647   1         if(status==1&&errors[2]==0)
 648   1         {
 649   2               if(set_password==1&&password_visble==0)
 650   2               {
 651   3                      OLED_ShowString(0,1,"Please enter",30);
 652   3                      OLED_ShowString(20,2,"new password:",30);
 653   3                      if(row==0)
 654   3              {
 655   4               for(n=0;n<i;n++)
 656   4               {
 657   5           OLED_ShowChar(8*n,5,input_buf[n],30);
 658   5               }
 659   4              }
 660   3              if(row_1==1)
 661   3              {
 662   4                for(n=0;n<16;n++)
 663   4               {
 664   5           OLED_ShowChar(8*n,5,input_buf[n],30);
 665   5               }
 666   4              }
 667   3               if(i==16&&row==0)
 668   3               {
 669   4                row++;row_1=1;
 670   4               }
 671   3               if(row==1)
 672   3               {
 673   4                 for(n=0;n<i-16;n++)
 674   4                 {
 675   5                 OLED_ShowChar(8*n,6,input_buf[n+16],30);
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 12  

 676   5                 }
 677   4               }
 678   3               if(row_2==1)
 679   3               {
 680   4                 for(n=0;n<16;n++)
 681   4                 {
 682   5                 OLED_ShowChar(8*n,6,input_buf[n+16],30);
 683   5                 }
 684   4               }
 685   3               if(i==32&&row==1)
 686   3               {
 687   4               row=2;row_2=1;
 688   4               }
 689   3         }
 690   2              if(set_password==1&&password_visble==1)
 691   2               {
 692   3                 if(visble_justnow==0)
 693   3                 {
 694   4                 OLED_Clear();
 695   4                 }
 696   3                 OLED_ShowString(0,1,"Please enter",30);
 697   3                 OLED_ShowString(20,2,"new password:",30);
 698   3                 if(row==0)
 699   3                {
 700   4               for(n=0;n<i;n++)
 701   4               {
 702   5           OLED_ShowChar(8*n,5,input[n],30);
 703   5               }
 704   4              }
 705   3              if(row_1==1)
 706   3              {
 707   4                for(n=0;n<16;n++)
 708   4               {
 709   5           OLED_ShowChar(8*n,5,input[n],30);
 710   5               }
 711   4              }
 712   3               if(i==16&&row==0)
 713   3               {
 714   4                row++;row_1=1;
 715   4               }
 716   3               if(row==1)
 717   3               {
 718   4                 for(n=0;n<i-16;n++)
 719   4                 {
 720   5                 OLED_ShowChar(8*n,6,input[n+16],30);
 721   5                 }
 722   4               }
 723   3               if(row_2==1)
 724   3               {
 725   4                 for(n=0;n<16;n++)
 726   4                 {
 727   5                 OLED_ShowChar(8*n,6,input[n+16],30);
 728   5                 }
 729   4               }
 730   3               if(i==32&&row==1)
 731   3               {
 732   4               row=2;row_2=1;
 733   4               }
 734   3                 visble_justnow=1;
 735   3                 if(visble_change_near==1)
 736   3                 {
 737   4                      visble_change_near=0;
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 13  

 738   4                 }
 739   3                }
 740   2      
 741   2               else if(set_fingerprint==1)
 742   2               {      
 743   3                  OLED_ShowString(0,2,"Fingerprint Mode",36);
 744   3                      OLED_ShowString(0,4,"1.add fingers",30);
 745   3                      OLED_ShowString(0,5,"2.delete fingers",30);
 746   3                      OLED_ShowString(0,6,"3.exit",30);
 747   3                      key_value=16;
 748   3                      keydown();
 749   3                      if(key_value==1)
 750   3                      {
 751   4                       add_fingerprint=1;
 752   4                       OLED_Clear();
 753   4                       Uart_Init_As608();
 754   4                       FPM10A_Add_Fingerprint();
 755   4                       Uart_Init_Slave();
 756   4                      }
 757   3                      else if(key_value==2)
 758   3                      {
 759   4                       del_fingerprint=1;
 760   4                       OLED_Clear();
 761   4                       Uart_Init_As608();
 762   4                       FPM10A_Delete_All_Fingerprint();
 763   4                       Uart_Init_Slave();
 764   4                      }
 765   3                      else if(key_value==3)
 766   3                      {
 767   4                        set_fingerprint=0;
 768   4                        status=0;
 769   4                        OLED_Clear();
 770   4                      }
 771   3      
 772   3               }
 773   2               else if(set_music==1)
 774   2               {
 775   3                 OLED_ShowString(0,0,"clock music is:",30);
 776   3                 OLED_ShowString(10,2,"song",30);
 777   3                 switch(key_value)
 778   3                 {
 779   4                       case 1:OLED_ShowChar(42,2,'1',30);
 780   4                       song1=1;
 781   4                       song2=0;
 782   4                       song3=0;
 783   4                       song4=0;
 784   4                       song5=0;
 785   4                       break;
 786   4                       case 2:OLED_ShowChar(42,2,'2',30);
 787   4                       song1=0;
 788   4                       song2=1;
 789   4                       song3=0;
 790   4                       song4=0;
 791   4                       song5=0;
 792   4                       break;
 793   4                       case 3:OLED_ShowChar(42,2,'3',30);
 794   4                       song1=0;
 795   4                       song2=0;
 796   4                       song3=1;
 797   4                       song4=0;
 798   4                       song5=0;
 799   4                       break;
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 14  

 800   4                       case 4:OLED_ShowChar(42,2,'4',30);
 801   4                       song1=0;
 802   4                       song2=0;
 803   4                       song3=0;
 804   4                       song4=1;
 805   4                       song5=0;
 806   4                       break;
 807   4                       case 5:OLED_ShowChar(42,2,'5',30);
 808   4                       song1=0;
 809   4                       song2=0;
 810   4                       song3=0;
 811   4                       song4=0;
 812   4                       song5=1;
 813   4                       break;
 814   4                       case 14:
 815   4                       if(song1==1)
 816   4                       {
 817   5                         OLED_Clear();
 818   5                         OLED_ShowString(0,0,"song1 is ready.",30);
 819   5                         song_set[0]=1;
 820   5                         EEPROM_WRITE(1,song_set,5);
 821   5                         delay_main(1000);
 822   5                         OLED_Clear();
 823   5                         set_music=0;
 824   5                         status=0;
 825   5                       }
 826   4                       if(song2==1)
 827   4                       {
 828   5                         OLED_Clear();
 829   5                         OLED_ShowString(0,0,"song2 is ready.",30);
 830   5                         song_set[0]=1;
 831   5                         EEPROM_WRITE(1,song_set,5);
 832   5                         delay_main(1000);
 833   5                         OLED_Clear();
 834   5                         set_music=0;
 835   5                         status=0;
 836   5                       }
 837   4                       if(song3==1)
 838   4                       {
 839   5                         OLED_Clear();
 840   5                         OLED_ShowString(0,0,"song3 is ready.",30);
 841   5                         song_set[0]=1;
 842   5                         EEPROM_WRITE(1,song_set,5); 
 843   5                         delay_main(1000);
 844   5                         OLED_Clear();
 845   5                         set_music=0;
 846   5                         status=0;
 847   5                       }
 848   4                       if(song4==1)
 849   4                       {
 850   5                         OLED_Clear();
 851   5                         OLED_ShowString(0,0,"song4 is ready.",30);
 852   5                         song_set[0]=1;
 853   5                         EEPROM_WRITE(1,song_set,5); 
 854   5                         delay_main(1000);
 855   5                         OLED_Clear();
 856   5                         set_music=0;
 857   5                         status=0;
 858   5                       }
 859   4                       if(song5==1)
 860   4                       {
 861   5                         OLED_Clear();
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 15  

 862   5                         OLED_ShowString(0,0,"song5 is ready.",30);
 863   5                         song_set[0]=1;
 864   5                         EEPROM_WRITE(1,song_set,5); 
 865   5                         delay_main(1000);
 866   5                         OLED_Clear();
 867   5                         set_music=0;
 868   5                         status=0;
 869   5                       }
 870   4                       break;
 871   4               case 15:set_music=0;
 872   4                       break;
 873   4                 }
 874   3               }
 875   2              }
 876   1      }
 877          
 878          
 879          void recv_from_slave(void) interrupt 4
 880          {  
 881   1              u8 Data;
 882   1              Data=SBUF;
 883   1              if(RI)
 884   1              {
 885   2                      if(Data==0x01)
 886   2                      {
 887   3                        if(is_lock==1)
 888   3                        {
 889   4                        set_password=0;
 890   4                    use_password=0;
 891   4                        use_rfid=0;//接受来自从机的bit
 892   4                        status=0;
 893   4                        is_lock=0;
 894   4                        ini_over=0;
 895   4                        open_just_now=1;
 896   4                        use_fingerprint=0;
 897   4                        add_fingerprint=0;
 898   4                        del_fingerprint=0;
 899   4                        set_fingerprint=0;
 900   4                        OLED_Clear();
 901   4                        }
 902   3                      }
 903   2                      if(Data==0x02)
 904   2                      {
 905   3                              clock_play_music = 1;
 906   3                      }
 907   2              
 908   2                      RI=0;
 909   2              }
 910   1      
 911   1      }
 912          void play_clock_music()
 913          {
 914   1                      if(clock_play_music==1)
 915   1                       {
 916   2                        if(song1==1)
 917   2                        { 
 918   3                          OLED_Clear();
 919   3                              OLED_ShowString(0,0,"Clock1 is on!",30);
 920   3                              OLED_ShowString(0,2,"music song1.",30);
 921   3                              Play_Music1();
 922   3                              OLED_Clear();
 923   3                              clock_play_music=0;
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 16  

 924   3      
 925   3                        }
 926   2                        if(song2==1)
 927   2                        { 
 928   3                          OLED_Clear();
 929   3                              OLED_ShowString(0,0,"Clock1 is on!",30);
 930   3                              OLED_ShowString(0,2,"music song2.",30);
 931   3                              Play_Music2();
 932   3                              OLED_Clear();
 933   3                              clock_play_music=0;
 934   3                        }
 935   2                        if(song3==1)
 936   2                        { 
 937   3                          OLED_Clear();
 938   3                              OLED_ShowString(0,0,"Clock1 is on!",30);
 939   3                              OLED_ShowString(0,2,"music song3.",30);
 940   3                              Play_Music3();
 941   3                              OLED_Clear();
 942   3                              clock_play_music=0;
 943   3                        }
 944   2                        if(song4==1)
 945   2                        { 
 946   3                          OLED_Clear();
 947   3                              OLED_ShowString(0,0,"Clock1 is on!",30);
 948   3                              OLED_ShowString(0,2,"music song4.",30);
 949   3                              Play_Music4();
 950   3                              OLED_Clear();
 951   3                              clock_play_music=0;
 952   3                        }
 953   2                        if(song5==1)
 954   2                        { 
 955   3                          OLED_Clear();
 956   3                              OLED_ShowString(0,0,"Clock1 is on!",30);
 957   3                              OLED_ShowString(0,2,"music song5.",30);
 958   3                              Play_Music3();
 959   3                              OLED_Clear();
 960   3                              clock_play_music=0;
 961   3                        }
 962   2                      }
 963   1      } 
 964          
 965          void main()     
 966          {               
 967   1                  
 968   1              Uart_Init_Slave();
 969   1                      OLED_Init();
 970   1                      EEPROM_init();
 971   1                      ES=1;
 972   1                      OLED_Clear();
 973   1                      MotorStop();
 974   1       //到时候加上
 975   1                      OLED_ShowString(7,1,"MultiFunc Lock",30);
 976   1                      OLED_ShowString(15,4,"made by  WJC",8);
 977   1                      OLED_ShowString(80,5," WXB",8);
 978   1                      OLED_ShowString(80,6," LQ",8); 
 979   1                      delay_ms(100); //important name 
 980   1                  OLED_Clear();       
 981   1                      while(1)
 982   1                      {       
 983   2                              keydown();
 984   2                              display_pros();
 985   2                              play_clock_music();
C51 COMPILER V9.01   PMPDATAR                                                              06/02/2021 20:52:43 PAGE 17  

 986   2                      } 
 987   1      }
 988          
 989          
 990          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5780    ----
   CONSTANT SIZE    =   2763    ----
   XDATA SIZE       =    122       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
